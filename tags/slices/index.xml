<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Slices on Shantanu Joshi</title>
    <link>http://localhost:1313/tags/slices/</link>
    <description>Recent content in Slices on Shantanu Joshi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) Shantanu Joshi 2015. Powered by hugo and theme is nofancy</copyright>
    <lastBuildDate>Mon, 21 Jul 2014 04:21:44 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/slices/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Small Gotcha in Go slices</title>
      <link>http://localhost:1313/post/slices/</link>
      <pubDate>Mon, 21 Jul 2014 04:21:44 +0000</pubDate>
      
      <guid>http://localhost:1313/post/slices/</guid>
      <description>&lt;p&gt;I am back to writing programs in Go after almost a year. Today, I ran into an issue at work that led me to re-read some important docs and revisit the fundamentals of slices in Go.&lt;/p&gt;

&lt;p&gt;The issue is best explained using the ( representative )code below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;func main(){

slice := make([]string, 5)
slice = append(slice, &amp;quot;foo&amp;quot;)
fmt.Println(slice)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output it provides was slightly confusing to me. I was expecting the output to be &lt;code&gt;[&amp;quot;foo&amp;quot;]&lt;/code&gt; instead it turned out to be :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[    &amp;quot;foo&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can verify it &lt;a href=&#34;http://play.golang.org/p/f1vw8_0cfM&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I thought that this was something to do with Slices so I read the following two blog posts again to see if I had forgotten something fundamental&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.golang.org/go-slices-usage-and-internals&#34;&gt;Go slices : usage and internal &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.golang.org/slices&#34;&gt;The mechanics of &amp;lsquo;append&amp;rsquo; &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While very useful in refreshing my memory of &lt;code&gt;slices&lt;/code&gt; and &lt;code&gt;append&lt;/code&gt; I wasn&amp;rsquo;t able to immediately pin point what was wrong. In order to quickly get the job done and test if I was on the right track I resorted to using unidiomatic go and basically treated the slice as a regular array and indexed into it directly to &amp;ldquo;append&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;After verifying that I was on the right track, I experimented with the bug to see if I could determine my error.&lt;/p&gt;

&lt;p&gt;Maybe it was a problem when  appending to an empty slice , so let me add some elements then try it. No dice. On second thoughts appending to an empty slice should never be a problem, that&amp;rsquo;s just absurd.&lt;/p&gt;

&lt;p&gt;After some more experimentation, I finally asked a colleague  and he pointed out my bug immediately. I had initialized the length and capacity of the slice to &lt;code&gt;5&lt;/code&gt; and that was the source of my problems. Thinking of it in terms of an empty slice was my biggest mistake. &lt;code&gt;Go automatically initializes the underlying array with the appropriate default value&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;intSlice := make([]int, 5) // underlying array is -&amp;gt; {0,0,0,0,0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the empty space which I thought was &lt;code&gt;&amp;lt;nil&amp;gt;&lt;/code&gt; turned out to be the empty string. In hindsight, I should have immediately discarded the thought that it was &lt;code&gt;&amp;lt;nil&amp;gt;&lt;/code&gt; as Go reports a nil value in the same format as I have used above.&lt;/p&gt;

&lt;p&gt;So because I had been lazy and specified both the length and capacity as one, make had gone an allocated the underlying array of my desired capacity but while I assumed the length would be zero it was actually 5.&lt;/p&gt;

&lt;p&gt;It can easily be verified by running the following snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;func main(){

slice := make([]string, 5)
slice = append(slice, &amp;quot;foo&amp;quot;)
fmt.Println(len(slice)) // output is 6. 

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The solution is as simple as :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;func main(){

slice := make([]string, 0, 5)
slice = append(slice, &amp;quot;foo&amp;quot;)
fmt.Println(slice) 

}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[&amp;quot;foo&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the capacity of the underlying array is &lt;code&gt;5&lt;/code&gt; but it&amp;rsquo;s length is &lt;code&gt;0&lt;/code&gt;( to start with) so &lt;code&gt;make&lt;/code&gt; can&amp;rsquo;t initialize any elements. Thus now when we use append, we get the expected result&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TL;DR:&lt;/strong&gt; &lt;em&gt;Don&amp;rsquo;t forget that Go helps out by automatically initialzing underlying array of a slice with sensible defaults.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>